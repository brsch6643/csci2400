b8 bd 6a e8 43 bd 68 b6 ff bf 68 4c 95 04 08 c3 2c b6 ff bf

first thing I did was figure out again where the buffer started
and that was where I would insert my exploit code.

I know that eax usually holds the return value by looking at the getbuf
code because the instructions said 1 was being returned and that was
exactly what was being pushed into eax at the end.

I found the value at the address at ebp which would be the old saved ebp value
after some trial and error.

So I wrote some assembly code moving my cookie into eax and the value of old ebp
into ebp, then pushing the address right after the function call getbuf in the text function.
I read online that the address after a function call is usually the return address.
So then I inserted the dissasembled code into the exploit string and that turned out
to be 16 bytes long which left 4 for the address to the exploit string itself.
